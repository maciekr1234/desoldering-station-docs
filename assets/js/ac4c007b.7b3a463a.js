"use strict";(globalThis.webpackChunkdocs_site=globalThis.webpackChunkdocs_site||[]).push([[8311],{863:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>a});const r=JSON.parse('{"id":"drivers/encoder","title":"Encoder Driver","description":"Rotary encoder driver with button support and LVGL integration.","source":"@site/docs/drivers/encoder.md","sourceDirName":"drivers","slug":"/drivers/encoder","permalink":"/desoldering-station-docs/docs/drivers/encoder","draft":false,"unlisted":false,"editUrl":"https://github.com/maciekr1234/desoldering-station/tree/master/docs-site/docs/drivers/encoder.md","tags":[],"version":"current","lastUpdatedAt":1764732173000,"sidebarPosition":6,"frontMatter":{"sidebar_position":6},"sidebar":"docsSidebar","previous":{"title":"Motor Driver","permalink":"/desoldering-station-docs/docs/drivers/motor-driver"},"next":{"title":"Motion Sensor Driver","permalink":"/desoldering-station-docs/docs/drivers/motion-sensor"}}');var i=t(4848),d=t(8453);const s={sidebar_position:6},c="Encoder Driver",o={},a=[{value:"Overview",id:"overview",level:2},{value:"Features",id:"features",level:2},{value:"Quadrature Encoding",id:"quadrature-encoding",level:2},{value:"API Reference",id:"api-reference",level:2},{value:"Constants",id:"constants",level:3},{value:"Class Definition",id:"class-definition",level:3},{value:"Debouncing",id:"debouncing",level:2},{value:"Example Usage",id:"example-usage",level:2},{value:"LVGL Integration",id:"lvgl-integration",level:2},{value:"Thread Safety",id:"thread-safety",level:2},{value:"Source Files",id:"source-files",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,d.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"encoder-driver",children:"Encoder Driver"})}),"\n",(0,i.jsx)(n.p,{children:"Rotary encoder driver with button support and LVGL integration."}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsxs)(n.p,{children:["The Encoder driver handles quadrature rotary encoder input for UI navigation. It includes software debouncing, direction detection, and integrates directly with LVGL through an ",(0,i.jsx)(n.code,{children:"lv_subject_t"})," for reactive UI updates."]}),"\n",(0,i.jsx)(n.h2,{id:"features",children:"Features"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Quadrature decoding"}),"\n",(0,i.jsx)(n.li,{children:"Software debouncing (25ms rotation, 50ms button)"}),"\n",(0,i.jsx)(n.li,{children:"Button press with debounce"}),"\n",(0,i.jsx)(n.li,{children:"Direction detection (CW/CCW)"}),"\n",(0,i.jsx)(n.li,{children:"Invertible direction"}),"\n",(0,i.jsx)(n.li,{children:"LVGL subject integration"}),"\n",(0,i.jsx)(n.li,{children:"Thread-safe with FreeRTOS mutex"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"quadrature-encoding",children:"Quadrature Encoding"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"State"}),(0,i.jsx)(n.th,{children:"A"}),(0,i.jsx)(n.th,{children:"B"}),(0,i.jsx)(n.th,{children:"CW Transition"}),(0,i.jsx)(n.th,{children:"CCW Transition"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"0"}),(0,i.jsx)(n.td,{children:"0"}),(0,i.jsx)(n.td,{children:"0"}),(0,i.jsx)(n.td,{children:"\u2192 State 1"}),(0,i.jsx)(n.td,{children:"\u2192 State 3"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"1"}),(0,i.jsx)(n.td,{children:"1"}),(0,i.jsx)(n.td,{children:"0"}),(0,i.jsx)(n.td,{children:"\u2192 State 2"}),(0,i.jsx)(n.td,{children:"\u2192 State 0"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"2"}),(0,i.jsx)(n.td,{children:"1"}),(0,i.jsx)(n.td,{children:"1"}),(0,i.jsx)(n.td,{children:"\u2192 State 3"}),(0,i.jsx)(n.td,{children:"\u2192 State 1"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"3"}),(0,i.jsx)(n.td,{children:"0"}),(0,i.jsx)(n.td,{children:"1"}),(0,i.jsx)(n.td,{children:"\u2192 State 0"}),(0,i.jsx)(n.td,{children:"\u2192 State 2"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"api-reference",children:"API Reference"}),"\n",(0,i.jsx)(n.h3,{id:"constants",children:"Constants"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"static constexpr uint32_t ENCODER_DEBOUNCE_MS = 25;  // Rotation debounce\nstatic constexpr uint32_t BUTTON_DEBOUNCE_MS = 50;   // Button debounce\n\nstatic constexpr uint8_t DIRECTION_NONE = 0x00;\nstatic constexpr uint8_t DIRECTION_CW = 0x10;\nstatic constexpr uint8_t DIRECTION_CCW = 0x20;\n"})}),"\n",(0,i.jsx)(n.h3,{id:"class-definition",children:"Class Definition"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"class Encoder {\npublic:\n    Encoder(pin_size_t pin_a, pin_size_t pin_b, pin_size_t pin_btn = 255);\n    \n    void begin();\n    void update();\n    \n    // Position reading\n    int32_t absolute();   // Get absolute position\n    int32_t relative();   // Get position change since last call (resets after read)\n    \n    // Button state\n    bool update_button();            // Update button state, returns true if changed\n    bool button_pressed() const;     // Current button state\n    bool button_changed() const;     // True if button state changed since last update\n    \n    // LVGL integration\n    lv_subject_t* subject();  // Get LVGL subject for reactive binding\n    \n    // Configuration\n    void set_inverted(bool inverted);  // Invert rotation direction\n};\n\n// Global encoder instance\nextern Encoder gEncoder;\n"})}),"\n",(0,i.jsx)(n.h2,{id:"debouncing",children:"Debouncing"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Parameter"}),(0,i.jsx)(n.th,{children:"Value"}),(0,i.jsx)(n.th,{children:"Purpose"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"ENCODER_DEBOUNCE_MS"})}),(0,i.jsx)(n.td,{children:"25ms"}),(0,i.jsx)(n.td,{children:"Filter rotation contact bounce"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"BUTTON_DEBOUNCE_MS"})}),(0,i.jsx)(n.td,{children:"50ms"}),(0,i.jsx)(n.td,{children:"Prevent button double-triggers"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"example-usage",children:"Example Usage"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'#include "drivers/encoder.h"\n\n// Uses global gEncoder instance, or create your own\nEncoder encoder(8, 9, 10);  // A=GPIO8, B=GPIO9, Button=GPIO10\n\nvoid setup() {\n    encoder.begin();\n    encoder.set_inverted(false);  // Set rotation direction\n}\n\nvoid ui_task() {\n    while (true) {\n        encoder.update();\n        \n        // Check rotation (resets after read)\n        int32_t delta = encoder.relative();\n        if (delta != 0) {\n            menu_navigate(delta);\n        }\n        \n        // Check button\n        if (encoder.update_button() && encoder.button_pressed()) {\n            menu_select();\n        }\n        \n        vTaskDelay(pdMS_TO_TICKS(10));\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"lvgl-integration",children:"LVGL Integration"}),"\n",(0,i.jsxs)(n.p,{children:["The encoder provides an ",(0,i.jsx)(n.code,{children:"lv_subject_t"})," for reactive LVGL binding:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"// Get the LVGL subject for direct binding\nlv_subject_t* enc_subject = gEncoder.subject();\n\n// Use with LVGL observers for reactive updates\nlv_obj_add_observer(slider, encoder_value_changed_cb, enc_subject);\n"})}),"\n",(0,i.jsx)(n.p,{children:"For LVGL input device integration:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"void encoder_read_cb(lv_indev_t* indev, lv_indev_data_t* data) {\n    gEncoder.update();\n    data->enc_diff = gEncoder.relative();\n    data->state = gEncoder.button_pressed() \n        ? LV_INDEV_STATE_PRESSED \n        : LV_INDEV_STATE_RELEASED;\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"thread-safety",children:"Thread Safety"}),"\n",(0,i.jsx)(n.p,{children:"The encoder uses a FreeRTOS mutex internally for thread-safe access to position counters and state."}),"\n",(0,i.jsx)(n.h2,{id:"source-files",children:"Source Files"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Header: ",(0,i.jsx)(n.code,{children:"include/drivers/encoder.h"})]}),"\n",(0,i.jsxs)(n.li,{children:["Implementation: ",(0,i.jsx)(n.code,{children:"src/drivers/encoder.cpp"})]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,d.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>c});var r=t(6540);const i={},d=r.createContext(i);function s(e){const n=r.useContext(d);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(d.Provider,{value:n},e.children)}}}]);