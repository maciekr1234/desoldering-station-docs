"use strict";(globalThis.webpackChunkdocs_site=globalThis.webpackChunkdocs_site||[]).push([[1313],{28453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>a});var r=i(96540);const t={},d=r.createContext(t);function l(e){const n=r.useContext(d);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),r.createElement(d.Provider,{value:n},e.children)}},65410:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>s});const r=JSON.parse('{"id":"drivers/adc","title":"ADC Driver","description":"Timer-driven ADC (Analog-to-Digital Converter) driver with automatic periodic sampling and filtering.","source":"@site/docs/drivers/adc.md","sourceDirName":"drivers","slug":"/drivers/adc","permalink":"/desoldering-station-docs/docs/drivers/adc","draft":false,"unlisted":false,"editUrl":"https://github.com/maciekr1234/desoldering-station/tree/master/docs-site/docs/drivers/adc.md","tags":[],"version":"current","lastUpdatedAt":1766792103000,"sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"docsSidebar","previous":{"title":"Drivers","permalink":"/desoldering-station-docs/docs/category/drivers"},"next":{"title":"PWM Driver","permalink":"/desoldering-station-docs/docs/drivers/pwm"}}');var t=i(74848),d=i(28453);const l={sidebar_position:1},a="ADC Driver",c={},s=[{value:"Overview",id:"overview",level:2},{value:"Features",id:"features",level:2},{value:"Architecture",id:"architecture",level:2},{value:"Channel Configuration",id:"channel-configuration",level:2},{value:"API Reference",id:"api-reference",level:2},{value:"Types",id:"types",level:3},{value:"Functions",id:"functions",level:3},{value:"Example Usage",id:"example-usage",level:2},{value:"Configuration",id:"configuration",level:2},{value:"Thread Safety",id:"thread-safety",level:2},{value:"Source Files",id:"source-files",level:2}];function o(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,d.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"adc-driver",children:"ADC Driver"})}),"\n",(0,t.jsx)(n.p,{children:"Timer-driven ADC (Analog-to-Digital Converter) driver with automatic periodic sampling and filtering."}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(n.p,{children:"The ADC driver provides hardware abstraction for the RP2040's 12-bit ADC with automatic periodic sampling. It uses a repeating timer to read ADC values at regular intervals, applies filtering (circular buffer averaging with outlier rejection), and stores results in a thread-safe manner using FreeRTOS mutex protection."}),"\n",(0,t.jsx)(n.h2,{id:"features",children:"Features"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Timer-driven periodic sampling (configured via ",(0,t.jsx)(n.code,{children:"CONFIG_ADC_TIMER_PERIOD_MS"}),")"]}),"\n",(0,t.jsx)(n.li,{children:"Circular buffer averaging with outlier rejection"}),"\n",(0,t.jsx)(n.li,{children:"FreeRTOS mutex protection for thread safety"}),"\n",(0,t.jsx)(n.li,{children:"Raw, filtered, and millivolt output for each channel"}),"\n",(0,t.jsxs)(n.li,{children:["Dynamic channel configuration based on ",(0,t.jsx)(n.code,{children:"config.h"})," pin definitions"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"architecture",children:"Architecture"}),"\n",(0,t.jsx)(n.mermaid,{value:"graph LR\n    Timer[Repeating Timer] --\x3e Sample[ADC Sample]\n    Sample --\x3e Buffer[Circular Buffer]\n    Buffer --\x3e Filter[Outlier Rejection]\n    Filter --\x3e Avg[Average]\n    Avg --\x3e Storage[Channel Data]\n    \n    subgraph Output\n        Raw[Raw ADC]\n        Filtered[Filtered ADC]\n        mV[Millivolts]\n    end\n    \n    Storage --\x3e Raw\n    Storage --\x3e Filtered\n    Storage --\x3e mV"}),"\n",(0,t.jsx)(n.h2,{id:"channel-configuration",children:"Channel Configuration"}),"\n",(0,t.jsxs)(n.p,{children:["Channels are dynamically configured based on pin definitions in ",(0,t.jsx)(n.code,{children:"config.h"}),":"]}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Channel Enum"}),(0,t.jsx)(n.th,{children:"Config Pin"}),(0,t.jsx)(n.th,{children:"Purpose"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"ADC_INPUT_AMBIENT_TEMP"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"CONFIG_PIN_AMBIENT_TEMP"})}),(0,t.jsx)(n.td,{children:"NTC ambient sensor"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"ADC_INPUT_PTC_TEMP"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"CONFIG_PIN_HEATER_TEMP"})}),(0,t.jsx)(n.td,{children:"PTC heater sensor"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"ADC_INPUT_VREF"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"CONFIG_PIN_VREF"})}),(0,t.jsx)(n.td,{children:"Voltage reference"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:"Channels are only included if their corresponding pin is not set to 255."}),"\n",(0,t.jsx)(n.h2,{id:"api-reference",children:"API Reference"}),"\n",(0,t.jsx)(n.h3,{id:"types",children:"Types"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"// Channel identifier type\ntypedef uint32_t adc_input_channel_t;\n\n// Channel data structure\ntypedef struct {\n    uint16_t adc_raw;      // Raw ADC value (0-4095)\n    uint16_t adc_filtered; // Filtered ADC value\n    uint16_t millivolts;   // Converted millivolt value\n} adc_input_channel_data_t;\n"})}),"\n",(0,t.jsx)(n.h3,{id:"functions",children:"Functions"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'#include "drivers/adc.h"\n\n// Initialize ADC and start periodic sampling timer\nvoid adc_input_init(void);\n\n// Stop sampling and deinitialize ADC\nvoid adc_input_deinit(void);\n\n// Get millivolt value for a channel\nuint16_t adc_input_get_millivolts(adc_input_channel_t channel);\n\n// Get ADC value (raw or filtered)\nuint16_t adc_input_get_adc(adc_input_channel_t channel, bool filtered);\n\n// Get full channel data structure\nint adc_input_get_channel(adc_input_channel_t channel, adc_input_channel_data_t* out_data);\n'})}),"\n",(0,t.jsx)(n.h2,{id:"example-usage",children:"Example Usage"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'#include "drivers/adc.h"\n#include "core/pico_log.h"\n\nvoid setup() {\n    // Initialize ADC with periodic sampling\n    adc_input_init();\n}\n\nvoid read_sensors() {\n    // Get filtered ADC value\n    uint16_t ptc_adc = adc_input_get_adc(ADC_INPUT_PTC_TEMP, true);\n    \n    // Get millivolt reading\n    uint16_t ptc_mv = adc_input_get_millivolts(ADC_INPUT_PTC_TEMP);\n    \n    // Get reference voltage\n    uint16_t vref_mv = adc_input_get_millivolts(ADC_INPUT_VREF);\n    \n    PICO_LOGI("ADC", "PTC: %u (%.1fmV), VREF: %umV", \n              ptc_adc, (float)ptc_mv, vref_mv);\n    \n    // Get full channel data\n    adc_input_channel_data_t data;\n    if (adc_input_get_channel(ADC_INPUT_AMBIENT_TEMP, &data) == PICO_OK) {\n        PICO_LOGI("ADC", "Ambient - Raw: %u, Filtered: %u, mV: %u",\n                  data.adc_raw, data.adc_filtered, data.millivolts);\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"configuration",children:"Configuration"}),"\n",(0,t.jsxs)(n.p,{children:["The ADC driver uses configuration values from ",(0,t.jsx)(n.code,{children:"config.h"}),":"]}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Define"}),(0,t.jsx)(n.th,{children:"Purpose"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"CONFIG_PIN_AMBIENT_TEMP"})}),(0,t.jsx)(n.td,{children:"GPIO pin for NTC sensor"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"CONFIG_PIN_HEATER_TEMP"})}),(0,t.jsx)(n.td,{children:"GPIO pin for PTC sensor"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"CONFIG_PIN_VREF"})}),(0,t.jsx)(n.td,{children:"GPIO pin for voltage reference"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"CONFIG_ADC_TIMER_PERIOD_MS"})}),(0,t.jsx)(n.td,{children:"Sampling interval in milliseconds"})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"thread-safety",children:"Thread Safety"}),"\n",(0,t.jsx)(n.p,{children:"All public functions are protected by a FreeRTOS mutex, making them safe to call from multiple tasks. The internal sampling timer runs independently and updates the channel data atomically."}),"\n",(0,t.jsx)(n.h2,{id:"source-files",children:"Source Files"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Header: ",(0,t.jsx)(n.code,{children:"include/drivers/adc.h"})]}),"\n",(0,t.jsxs)(n.li,{children:["Implementation: ",(0,t.jsx)(n.code,{children:"src/drivers/adc.cpp"})]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,d.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(o,{...e})}):o(e)}}}]);